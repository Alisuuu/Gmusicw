<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>YouTube Background Player</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.polyfill.io/v3/polyfill.min.js?features=default,fetch,Promise"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000;
        }

        #player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-image 0.5s ease-in-out;
        }

        #background-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            z-index: 1;
        }

        @supports not ((-webkit-backdrop-filter: none) or (backdrop-filter: none)) {
          #background-overlay {
            background: rgba(0, 0, 0, 0.7);
          }
        }

        #visualizer-container {
            position: absolute;
            inset: 0;
            z-index: 6; /* On top of everything, but still allows interaction */
            pointer-events: none;
            display: flex;
            justify-content: space-around; /* Distribute elements horizontally */
            align-items: flex-end; /* Start from the bottom */
            overflow: hidden;
        }

        .visualizer-element {
            width: 20px;
            height: 20px;
            transform-origin: bottom;
            opacity: 0;
            /* box-shadow will be set by JS for random colors */
        }

        .visualizer-element.jumping {
            animation: jump 0.5s infinite alternate; /* Adjust duration and timing as needed */
        }

        @keyframes jump {
            from { opacity: 0.3; transform: scaleY(1); } /* Changed from 0.7 to 0.3 */
            to { opacity: 0.6; transform: scaleY(5); } /* Changed from 1 to 0.6 */
        }

        #video-player {
            width: 75%;
            height: 100%;
            display: none;
            z-index: 2;
        }

        #playlist-sidebar {
            width: 25%;
            height: 100%;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.6);
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
            padding: 1rem;
            padding-bottom: 8rem;
            z-index: 3;
        }

        @supports not ((-webkit-backdrop-filter: none) or (backdrop-filter: none)) {
          #playlist-sidebar {
            background-color: rgba(0, 0, 0, 0.8);
          }
        }

        .playlist-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem;
            margin-bottom: 0.6rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            cursor: pointer;
        }

        .playlist-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .playlist-thumb {
            width: 70px;
            height: 45px;
            border-radius: 0.25rem;
            object-fit: cover;
            flex-shrink: 0;
        }

        .playlist-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            font-size: 0.9rem;
            overflow: hidden;
        }

        .playlist-title {
            font-weight: 600;
            color: #fff;
            word-break: break-word;
            line-height: 1.2rem;
        }

        .playlist-channel {
            color: #ddd;
            font-size: 0.8rem;
            line-height: 1rem;
        }

        #controls {
            position: fixed;
            bottom: 2.5rem;
            left: 50%;
            width: 90%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 5;
            transition: background-image 0.5s ease-in-out;
        }

        @supports not ((-webkit-backdrop-filter: none) or (backdrop-filter: none)) {
          #controls {
            background-color: rgba(0, 0, 0, 0.8);
          }
        }

        .control-button {
            padding: 0.7rem;
            border-radius: 9999px;
            background-color: rgba(0, 0, 0, 0.5);
            transition: transform 0.3s;
        }

        .control-button:hover {
            transform: scale(1.1);
        }

        #initial-play-button.fade-out {
            animation: fadeOut 0.5s forwards;
        }

        #controls.fade-in {
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            #player-container {
                flex-direction: column;
            }

            #video-player {
                width: 100%;
                height: 50%;
            }

            #playlist-sidebar {
                width: 100%;
                height: 100%;
                display: block;
                padding: 0.5rem 0.5rem 8rem;
                border-top-left-radius: 1.5rem;
                border-top-right-radius: 1.5rem;
            }

            .playlist-thumb {
                width: 80px;
                height: 50px;
            }

            .playlist-info {
                font-size: 1rem;
            }

            .playlist-title {
                font-size: 0.95rem;
            }

            .playlist-channel {
                font-size: 0.8rem;
            }

            #controls {
                flex-direction: column;
                gap: 0.5rem;
                padding: 1rem;
            }

            #controls .song-info {
                display: none;
            }

            #controls .player-controls {
                width: 100%;
            }
        }

        /* Custom styles for the volume slider */
        .custom-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
            margin-top: -7px; /* Adjust to center the thumb vertically */
        }

        .custom-range::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        .custom-range::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            background: #4a5568; /* Tailwind gray-700 */
            border-radius: 5px;
        }

        .custom-range::-moz-range-track {
            width: 100%;
            height: 2px;
            background: #4a5568; /* Tailwind gray-700 */
            border-radius: 5px;
        }
    </style>
    <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body class="bg-gray-900 text-gray-200">
    <div id="player-container">
        <div id="background-overlay"></div>
        <div id="video-player"></div>

        <div id="playlist-sidebar" class="hidden"></div>

        <!-- Visualizer Container -->
        <div id="visualizer-container">
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
            <div class="visualizer-element"></div>
        </div>

        <div id="initial-play-button" class="absolute inset-0 flex items-center justify-center z-10">
            <button class="w-24 h-24 bg-white/20 rounded-full flex items-center justify-center backdrop-blur-md">
                <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" fill="currentColor" class="bi bi-play-fill text-white" viewBox="0 0 16 16">
                    <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                </svg>
            </button>
        </div>
    </div>

    <div id="controls" class="items-center hidden">
        <div class="song-info flex items-center gap-4 w-1/4">
            <img id="current-song-image" src="" class="w-12 h-12 rounded-md">
            <div>
                <p id="current-song-title" class="font-bold text-white truncate">Song Title</p>
                <p id="current-song-artist" class="text-gray-400 truncate">Artist</p>
            </div>
        </div>

        <div class="player-controls flex flex-col items-center gap-2 w-1/2">
            <div class="flex items-center gap-2">
                <button id="prev-btn" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-skip-start-fill" viewBox="0 0 16 16">
                      <path d="M4 4a.5.5 0 0 1 1 0v3.248l6.267-3.636c.54-.313 1.232.066 1.232.696v7.384c0 .63-.692 1.01-1.232.697L5 8.753V12a.5.5 0 0 1-1 0V4z"/>
                    </svg>
                </button>
                <button id="play-pause-btn" class="control-button p-2">
                    <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
                      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                    </svg>
                    <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-pause-fill hidden" viewBox="0 0 16 16">
                      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/>
                    </svg>
                </button>
                <button id="next-btn" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-skip-end-fill" viewBox="0 0 16 16">
                      <path d="M12.5 4a.5.5 0 0 0-1 0v3.248L5.233 3.612C4.693 3.3 4 3.678 4 4.308v7.384c0 .63.692 1.01 1.233.697L11.5 8.753V12a.5.5 0 0 0 1 0V4z"/>
                    </svg>
                </button>
                <button id="shuffle-btn" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-shuffle" viewBox="0 0 16 16">
                      <path fill-rule="evenodd" d="M0 3.5A.5.5 0 0 1 .5 3H1c2.202 0 3.827 1.24 4.874 2.418.49.552.865 1.102 1.126 1.532.26-.43.636-.98 1.126-1.532C9.173 4.24 10.798 3 13 3h.5a.5.5 0 0 1 0 1H13c-1.798 0-3.173 1.01-4.126 2.082A9.624 9.624 0 0 0 7.556 8a9.624 9.624 0 0 0 1.317 1.918C9.828 10.99 11.202 12 13 12h.5a.5.5 0 0 1 0 1H13c-2.202 0-3.827-1.24-4.874-2.418A10.595 10.595 0 0 1 7 9.05c-.26.43-.636.98-1.126 1.532C4.827 11.76 3.202 13 1 13H.5a.5.5 0 0 1 0-1H1c1.798 0 3.173-1.01 4.126-2.082A9.624 9.624 0 0 0 6.444 8a9.624 9.624 0 0 0-1.317-1.918C4.172 5.01 2.798 4 1 4H.5a.5.5 0 0 1-.5-.5z"/>
                      <path d="M13 5.466V1.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384l-2.36 1.966a.25.25 0 0 1-.41-.192zm0 9v-3.932a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384l-2.36 1.966a.25.25 0 0 1-.41-.192z"/>
                    </svg>
                </button>
            </div>
            <div class="flex items-center gap-2 w-full">
                <span id="current-time" class="text-white text-sm">0:00</span>
                <div id="progress-bar-container" class="w-full h-1 bg-gray-600 rounded-full cursor-pointer">
                    <div id="progress-bar" class="h-full bg-white rounded-full"></div>
                </div>
                <span id="duration" class="text-white text-sm">0:00</span>
            </div>
        </div>
        
        <div class="flex justify-end w-1/4">
            <input type="range" id="volumeSlider" min="0" max="10" value="10" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer custom-range">
            <span id="volumeValue" class="text-white text-sm ml-2">10</span>
        </div>
    </div>

    <script>
        const YOUTUBE_API_KEY = 'AIzaSyAv0q4vZqw72Xt9dhQQBWALDT4aasixuKA';
        const YOUTUBE_API_PLAYLIST_ITEMS_ENDPOINT = 'https://www.googleapis.com/youtube/v3/playlistItems';
        const YOUTUBE_API_VIDEOS_ENDPOINT = 'https://www.googleapis.com/youtube/v3/videos';
        const PLAYLIST_ID = 'PLM2V-zC1RStdE8dOpKnw25qUsSXz-YtTo'; // This will be a YouTube playlist ID, as Invidious uses YouTube IDs
        
        let player; // This will no longer be a YT.Player object, but a reference to the iframe
        let playlistItems = [];
        let originalPlaylist = [];
        let currentVideoIndex = 0;
        let isPlayerReady = false;
        let isShuffle = false;
        let progressInterval;
        let nextPageToken = '';

        const playerContainer = document.getElementById('player-container');
        const controlsDiv = document.getElementById('controls');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const nextBtn = document.getElementById('next-btn');
        const prevBtn = document.getElementById('prev-btn');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const videoPlayer = document.getElementById('video-player');
        const playlistSidebar = document.getElementById('playlist-sidebar');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const currentSongImage = document.getElementById('current-song-image');
        const currentSongTitle = document.getElementById('current-song-title');
        const currentSongArtist = document.getElementById('current-song-artist');
        const currentTime = document.getElementById('current-time');
        const duration = document.getElementById('duration');
        const progressBarContainer = document.getElementById('progress-bar-container');
        const progressBar = document.getElementById('progress-bar');
        const initialPlayButton = document.getElementById('initial-play-button');
        const visualizerContainer = document.getElementById('visualizer-container');
        const visualizerElements = document.querySelectorAll('.visualizer-element');

        // No longer using onYouTubeIframeAPIReady, call loadPlaylistData directly
        document.addEventListener('DOMContentLoaded', loadPlaylistData);

        // This function is called by the YouTube Iframe Player API when it's ready
        function onYouTubeIframeAPIReady() {
            if (playlistItems.length > 0) {
                createPlayer();
                loadVideo(currentVideoIndex);
            }
        }

        async function loadPlaylistData(pageToken = '') {
            try {
                let endpoint = `${YOUTUBE_API_PLAYLIST_ITEMS_ENDPOINT}?part=snippet,contentDetails&playlistId=${PLAYLIST_ID}&key=${YOUTUBE_API_KEY}&maxResults=50`;
                if (pageToken) {
                    endpoint += `&pageToken=${pageToken}`;
                }

                const response = await fetch(endpoint);
                const data = await response.json();
                
                if (data.error) {
                    console.error('YouTube API Error:', data.error.message);
                    return;
                }
                
                nextPageToken = data.nextPageToken || '';
                const videoIds = data.items.map(item => item.contentDetails.videoId);

                // Fetch video details for duration and high-quality thumbnails
                if (videoIds.length > 0) {
                    const videoDetailsEndpoint = `${YOUTUBE_API_VIDEOS_ENDPOINT}?part=snippet,contentDetails&id=${videoIds.join(',')}&key=${YOUTUBE_API_KEY}`;
                    const videoDetailsResponse = await fetch(videoDetailsEndpoint);
                    const videoDetailsData = await videoDetailsResponse.json();

                    const videoDetailsMap = new Map();
                    videoDetailsData.items.forEach(item => {
                        videoDetailsMap.set(item.id, item);
                    });

                    const formattedNewItems = data.items.map(item => {
                        const videoDetail = videoDetailsMap.get(item.contentDetails.videoId);
                        const durationIso = videoDetail?.contentDetails?.duration; // e.g., PT1M30S
                        let durationSeconds = 0;
                        if (durationIso) {
                            const matches = durationIso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
                            if (matches) {
                                const hours = parseInt(matches[1] || 0, 10);
                                const minutes = parseInt(matches[2] || 0, 10);
                                const seconds = parseInt(matches[3] || 0, 10);
                                durationSeconds = hours * 3600 + minutes * 60 + seconds;
                            }
                        }

                        return {
                            snippet: {
                                resourceId: {
                                    videoId: item.contentDetails.videoId
                                },
                                thumbnails: {
                                    default: { url: item.snippet.thumbnails.default?.url || '' },
                                    high: { url: item.snippet.thumbnails.high?.url || '' }
                                },
                                title: item.snippet.title,
                                videoOwnerChannelTitle: item.snippet.videoOwnerChannelTitle || item.snippet.channelTitle,
                                duration: durationSeconds // Duration in seconds
                            }
                        };
                    });

                    playlistItems = playlistItems.concat(formattedNewItems);
                    originalPlaylist = [...playlistItems];
                }

                if (playlistItems.length > 0 && !player) {
                    setBackground(playlistItems[currentVideoIndex].snippet.thumbnails.high.url);
                    // onYouTubeIframeAPIReady will create the player
                } else if (playlistItems.length > 0) {
                    renderPlaylist();
                }

            } catch (error) {
                console.error('Network or API error:', error);
            }
        }

        playlistSidebar.addEventListener('scroll', () => {
            if (playlistSidebar.scrollTop + playlistSidebar.clientHeight >= playlistSidebar.scrollHeight - 100) {
                if (nextPageToken) {
                    loadPlaylistData(nextPageToken);
                }
            }
        });

        initialPlayButton.addEventListener('click', () => {
            if (isPlayerReady) {
                // Autoplay policy: Browsers may block autoplay with sound until user interaction.
                // The video is set to autoplay in createPlayer(), but if it's blocked, this click will start it.
                initialPlayButton.classList.add('fade-out');
                controlsDiv.classList.remove('hidden');
                controlsDiv.classList.add('fade-in');
                playlistSidebar.classList.remove('hidden');

                initialPlayButton.addEventListener('animationend', () => {
                    initialPlayButton.style.display = 'none';
                });
            }
        });

        function setBackground(imageUrl) {
            playerContainer.style.backgroundImage = `url('${imageUrl}')`;
            controlsDiv.style.backgroundImage = `url('${imageUrl}')`;
        }

        function createPlayer() {
            player = new YT.Player('video-player', {
                videoId: playlistItems[currentVideoIndex].snippet.resourceId.videoId,
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                },
                playerVars: {
                    'autoplay': 1, // Set to 1 to attempt autoplay
                    'modestbranding': 1,
                    'controls': 0
                }
            });
        }
        
        
        
        function onPlayerReady(event) {
            isPlayerReady = true;
            videoPlayer.style.display = 'block';
            updatePlayPauseIcon(1); // Assume playing initially
            // Start progress bar update
            progressInterval = setInterval(updateProgressBar, 1000);
            // Visualizer elements will be handled by onPlayerStateChange
        }

        function onPlayerStateChange(event) {
            switch (event.data) {
                case YT.PlayerState.ENDED:
                    nextVideo();
                    break;
                case YT.PlayerState.PLAYING:
                    updatePlayPauseIcon(1); // Show pause icon
                    // Start visualizer animation
                    visualizerElements.forEach((el, index) => {
                        el.classList.add('jumping');
                        el.style.animationDelay = `${index * 0.05}s`;
                        el.style.backgroundColor = getRandomVibrantColor();
                        el.style.boxShadow = `0 0 5px ${el.style.backgroundColor}, 0 0 10px ${el.style.backgroundColor}`;
                    });
                    break;
                case YT.PlayerState.PAUSED:
                    updatePlayPauseIcon(0); // Show play icon
                    // Stop visualizer animation
                    visualizerElements.forEach(el => {
                        el.classList.remove('jumping');
                    });
                    break;
                case YT.PlayerState.BUFFERING:
                    // Optionally handle buffering state
                    break;
                case YT.PlayerState.CUED:
                    // Optionally handle cued state
                    break;
            }
        }

        function formatTime(time) {
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        function updateProgressBar() {
            if (!isPlayerReady || !player.getDuration) return;

            const currentTimeValue = player.getCurrentTime();
            const durationValue = player.getDuration();

            currentTime.textContent = formatTime(currentTimeValue);
            duration.textContent = formatTime(durationValue);

            const progress = (currentTimeValue / durationValue) * 100;
            progressBar.style.width = `${progress}%`;
        }

        progressBarContainer.addEventListener('click', (e) => {
            if (!isPlayerReady || !player.getDuration) return;

            const rect = progressBarContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const width = rect.width;
            const durationValue = player.getDuration();
            
            const seekTime = (clickX / width) * durationValue;
            player.seekTo(seekTime, true);
        });

        function updatePlayPauseIcon(isPlaying) {
            if (isPlaying) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            } else {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
        }

        function togglePlayPause() {
            if (!isPlayerReady) return;
            if (player.getPlayerState() === YT.PlayerState.PLAYING || player.getPlayerState() === YT.PlayerState.BUFFERING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        function nextVideo() {
            if (isShuffle) {
                currentVideoIndex = Math.floor(Math.random() * playlistItems.length);
            } else {
                currentVideoIndex = (currentVideoIndex + 1) % playlistItems.length;
            }
            loadVideo(currentVideoIndex);
        }
        
        function prevVideo() {
            currentVideoIndex = (currentVideoIndex - 1 + playlistItems.length) % playlistItems.length;
            loadVideo(currentVideoIndex);
        }

        function shufflePlaylist() {
            isShuffle = !isShuffle;
            updateShuffleButton();

            if (isShuffle) {
                for (let i = playlistItems.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [playlistItems[i], playlistItems[j]] = [playlistItems[j], playlistItems[i]];
                }
            } else {
                playlistItems = [...originalPlaylist];
            }

            currentVideoIndex = 0;
            renderPlaylist();
            loadVideo(currentVideoIndex);
        }

        function updateShuffleButton() {
            if (isShuffle) {
                shuffleBtn.classList.add('bg-blue-600');
            } else {
                shuffleBtn.classList.remove('bg-blue-600');
            }
        }

        function getRandomVibrantColor() {
            const hue = Math.floor(Math.random() * 360);
            const saturation = 90 + Math.random() * 10; // 90-100% saturation
            const lightness = 50 + Math.random() * 10; // 50-60% lightness
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function loadVideo(index) {
            const video = playlistItems[index].snippet;
            setBackground(video.thumbnails.high.url);
            
            const videoId = video.resourceId.videoId;
            
            if (player) {
                player.loadVideoById(videoId);
            } else {
                // If player is not yet initialized, onYouTubeIframeAPIReady will handle it
                // This case should ideally not be hit if onYouTubeIframeAPIReady is working correctly
            }
            
            renderPlaylist();

            currentSongImage.src = video.thumbnails.default.url;
            currentSongTitle.textContent = video.title;
            currentSongArtist.textContent = video.videoOwnerChannelTitle || 'Desconhecido';
        }

        function renderPlaylist() {
            playlistSidebar.innerHTML = "";
            playlistItems.forEach((item, index) => {
                const isActive = index === currentVideoIndex;
                const div = document.createElement('div');
                div.className = `playlist-item ${isActive ? 'bg-blue-600' : ''}`;
                div.innerHTML = `
                    <img src="${item.snippet.thumbnails.default.url}" class="playlist-thumb">
                    <div class="playlist-info">
                        <span class="playlist-title">${item.snippet.title}</span>
                        <span class="playlist-channel">${item.snippet.videoOwnerChannelTitle || 'Desconhecido'}</span>
                    </div>
                `;
                div.addEventListener('click', () => {
                    currentVideoIndex = index;
                    loadVideo(index);
                });
                playlistSidebar.appendChild(div);
            });
        }

        playPauseBtn.addEventListener('click', togglePlayPause);
        nextBtn.addEventListener('click', nextVideo);
        prevBtn.addEventListener('click', prevVideo);
        shuffleBtn.addEventListener('click', shufflePlaylist);

        // Volume control
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValueSpan = document.getElementById('volumeValue');

        volumeSlider.addEventListener('input', () => {
            if (player) {
                const volume = volumeSlider.value * 10; // Scale 0-10 to 0-100
                player.setVolume(volume); 
                volumeValueSpan.textContent = volumeSlider.value;
            }
        });
    </script>
</body>
</html>
